= Implementing Replicated Entities in Java

include::ROOT:partial$include.adoc[]

ifdef::todo[TODO: add glossary link for Replicated Entity to the main docs]

Replicated Entities distribute state using a https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type[conflict-free replicated data type (CRDT)]. Data is shared across multiple instances of a Replicated Entity and is eventually consistent to provide high availability with low latency. The underlying CRDT semantics allow Replicated Entity instances to update their state independently and concurrently and without coordination. The state changes will always converge without conflicts, but note that with the state being eventually consistent, reading the current data may return an out-of-date value.

Akka Serverless needs to serialize the data to replicate, and this is done with Protocol Buffers using `protobuf` types. While Protocol Buffers are the recommended format for state, we recommend that you do not use your service's public `protobuf` messages in the replicated data. This may introduce some overhead to convert from one type to the other, but allows the service public interface logic to evolve independently of the data format, which should be private.

The steps necessary to implement a Replicated Entity include:

. Defining the API and domain objects in `.proto` files.
. Implementing behavior in command handlers.
. Creating and initializing the Replicated Entity.

The sections on this page walk through these steps using a shopping cart service as an example.


== Defining the `proto` files

NOTE: Our Replicated Entity example is a shopping cart service.

The following `shoppingcart_domain.proto` file defines our "Shopping Cart" Replicated Entity. The entity manages line items of a cart and stores these as a <<_replicated_counter_map>>, mapping from each item's product details to its quantity. The counter for each item can be incremented independently in separate Replicated Entity instances and will converge to a total quantity.

[source,proto]
.src/main/proto/shoppingcart/shoppingcart_domain.proto
----
include::example$java-replicatedentity-shopping-cart/src/main/proto/shoppingcart/shoppingcart_domain.proto[]
----

<1> Any classes generated from this protobuf file will be in the Java package `com.example.shoppingcart.domain`.
<2> Import the Akka Serverless protobuf annotations, or options.
<3> Let the messages declared in this protobuf file be inner classes to the Java class `ShoppingCartDomain`.
<4> The protobuf option `(akkaserverless.file).replicated_entity` is specific to code-generation as provided by the Akka Serverless Maven plugin.
<5> `name` denotes the base name for the Replicated Entity. The code-generation will create initial sources `ShoppingCart` and `ShoppingCartIntegrationTest`. Once these files exist, they are not overwritten, so you can freely add logic to them.
<6> `entity_type` is a unique identifier for data replication. The entity name may be changed even after data has been created, the `entity_type` can't be changed.
<7> `replicated_counter_map` describes the Replicated Data type for this entity.
<8> `key` points to the protobuf message representing the counter map's key type.

NOTE: Each Replicated Entity is associated with one underlying Replicated Data type. Replicated Data types that are generic, accepting type parameters for key, value, or element types, are used with `protobuf` messages and can represent structured data. In this shopping cart example, the keys of the counter map are products that have an id and name.

The `shoppingcart_api.proto` file defines the commands we can send to the shopping cart service to manipulate or access the cart's state. They make up the service API:

[source,proto]
.src/main/proto/shoppingcart/shoppingcart_api.proto
----
include::example$java-replicatedentity-shopping-cart/src/main/proto/shoppingcart/shoppingcart_api.proto[]
----
<1> Any classes generated from this protobuf file will be in the Java package `com.example.shoppingcart`.
<2> Import the Akka Serverless protobuf annotations, or options.
<3> Let the messages declared in this protobuf file be inner classes to the Java class `ShoppingCartApi`.
<4> We use protobuf messages to describe the Commands that our service handles. They may contain other messages to represent structured data.
<5> Every Command must contain a `string` field that contains the entity ID and is marked with the `(akkaserverless.field).entity_key` option.
<6> Messages describe the return value for our API. For methods that don't have return values, we use `google.protobuf.Empty`.
<7> The service descriptor shows the API of the entity. It lists the methods a client can use to issue Commands to the entity.
<8> The protobuf option `(akkaserverless.service)`  is specific to code-generation as provided by the Akka Serverless Maven plugin and points to the protobuf definition `ShoppingCart` we've seen above (in the `com.example.shoppingcart.domain` package).


== Implementing behavior

A Replicated Entity implementation is a Java class where you define how each command is handled. The class `ShoppingCart` gets generated for us based on the `shoppingcart_api.proto` and `shoppingcart_domain.proto` definitions. Once the `ShoppingCart.java` file exist, it is not overwritten, so you can freely add logic to it. `ShoppingCart` extends the generated class `AbstractShoppingCart` which we're not supposed to change as it gets regenerated in case we update the protobuf descriptors. `AbstractShoppingCart` contains all method signatures corresponding to the API of the service. If you change the API you will see compilation errors in the `ShoppingCart` class and you have to implement the methods required by `AbstractShoppingCart`.

[source,java]
.src/main/java/com/example/shoppingcart/domain/ShoppingCart.java
----
include::example$java-replicatedentity-shopping-cart/src/main/java/com/example/shoppingcart/domain/ShoppingCart.java[tag=class]
----
<1> Extends the generated `AbstractShoppingCart`, which extends link:{attachmentsdir}/api/com/akkaserverless/javasdk/replicatedentity/ReplicatedCounterMapEntity.html[`ReplicatedCounterMapEntity` {tab-icon}, window="new"].

We need to implement all methods our Replicated Entity offers as https://developer.lightbend.com/docs/akka-serverless/reference/glossary.html#command_handler[_command handlers_].

The code-generation will generate an implementation class with an initial empty implementation which we'll discuss below.

Command handlers are implemented in the `ShoppingCart` class as methods that override abstract methods from `AbstractShoppingCart`. The methods take the current data value as the first parameter and the request message as the second parameter. They return an `Effect`, which describes next processing actions, such as updating state and sending a reply.

When adding or changing the `rpc` definitions, including name, parameter and return messages, in the `.proto` files the corresponding methods are regenerated in the abstract class (`AbstractShoppingCart`). This means that the Java compiler will assist you with such changes. The IDE can typically fill in missing method signatures and such.

=== Updating state

In the example below, the `AddItem` service call uses the request message `AddLineItem`. It returns an `Effect` to update the underlying data and then send a reply.

IMPORTANT: The **only** way for a command handler to modify the underlying data for a Replicated Entity is by returning an update effect with an updated Replicated Data object. Note that Replicated Data objects are immutable, with each modifying method returning a new instance of the Replicated Data type.

[source,java,indent=0]
.src/main/java/com/example/shoppingcart/domain/ShoppingCart.java
----
include::example$java-replicatedentity-shopping-cart/src/main/java/com/example/shoppingcart/domain/ShoppingCart.java[tag=addItem]
----
<1> The validation ensures quantity of items added is greater than zero and it fails calls with illegal values by returning an `Effect` with `effects().error`.
<2> From the current incoming `AddLineItem` we create a new `Product` object to represent the item's key in the counter map.
<3> We increment the counter for this item in the cart. A new counter will be created if the cart doesn't contain this item already.
<4> We update the underlying data for the Replicated Entity by returning an `Effect` with `effects().update` and the updated data object.
<5> An acknowledgment that the command was successfully processed is sent with a reply message.

=== Retrieving state

The following example shows the implementation of the `GetCart` command handler. This command handler is a read-only command handler--it doesn't update the state, it just returns it.

IMPORTANT: The state of Replicated Entities is eventually consistent. An individual Replicated Entity instance may have an out-of-date value, if there are concurrent modifications made by another instance.

[source,java,indent=0]
.src/main/java/com/example/shoppingcart/domain/ShoppingCart.java
----
include::example$java-replicatedentity-shopping-cart/src/main/java/com/example/shoppingcart/domain/ShoppingCart.java[tag=getCart]
----
<1> The current data is passed to the method. Note that this may not be the most up-to-date value, with concurrent modifications made by other instances of this Replicated Entity being replicated eventually.
<2> We convert the domain representation to the API representation that is sent as a reply by returning an `Effect` with `effects().reply`.

=== Deleting state

The following example shows the implementation of the `RemoveCart` command handler. Replicated Entity instances for a particular entity identifier can be deleted, using a delete `Effect`. Once deleted, an entity instance cannot be recreated, and all subsequent commands for that entity identifier will be rejected with an error.

IMPORTANT: Caution should be taken with creating and deleting Replicated Entities, as Akka Serverless maintains the replicated state in memory and also retains tombstones for each deleted entity. Over time, if many Replicated Entities are created and deleted, this will result in hitting memory limits.

[source,java,indent=0]
.src/main/java/com/example/shoppingcart/domain/ShoppingCart.java
----
include::example$java-replicatedentity-shopping-cart/src/main/java/com/example/shoppingcart/domain/ShoppingCart.java[tag=removeCart]
----
<1> The Replicated Entity instances for the associated entity key are deleted by using `effects().delete`.


== Registering the Entity

To make Akka Serverless aware of the Replicated Entity, we need to register it with the service.

From the code-generation, the registration gets automatically inserted in the generated `AkkaServerlessFactory.withComponents` method from the `Main` class.

[source,java]
.src/main/java/com/example/shoppingcart/Main.java
----
include::example$java-replicatedentity-shopping-cart/src/main/java/com/example/shoppingcart/Main.java[]
----

By default, the generated constructor has a `ReplicatedEntityContext` parameter, but you can change this to accept other parameters. If you change the constructor of the `ShoppingCart` class you will see a compilation error here, and you have to adjust the factory function that is passed to `AkkaServerlessFactory.withComponents`.

When more components are added, the `AkkaServerlessFactory` is regenerated and you have to adjust the registration from the `Main` class.


== Replicated Data types

Each Replicated Entity is associated with one underlying Replicated Data type. Counter, Register, Set, and Map data structures are available. This section describes how to configure and implement a Replicated Entity with each of the Replicated Data types.

IMPORTANT: The **only** way for a command handler to modify the underlying data for a Replicated Entity is by returning an update effect with an updated Replicated Data object. Note that Replicated Data objects are immutable, with each modifying method returning a new instance of the Replicated Data type.


=== Replicated Counter

A link:{attachmentsdir}/api/com/akkaserverless/javasdk/replicatedentity/ReplicatedCounter.html[`ReplicatedCounter` {tab-icon}, window="new"] can be incremented and decremented.

To configure a Replicated Entity with a Replicated Counter, use the `replicated_counter` option when <<_defining_the_proto_files,defining the `proto` file>> for the entity domain:

[source,proto]
.src/main/proto/replicated/counter_domain.proto
----
include::example$replicatedentity-examples/src/main/proto/replicated/counter_domain.proto[tag=replicated_entity]
----

<1> Specify the Replicated Data type as a Replicated Counter.

When implementing a Replicated Counter entity, the state can be updated by calling the `increment` or `decrement` methods on the current data object, and then triggering an update with the modified data object:

[source,java,indent=0]
.src/main/java/com/example/replicated/counter/domain/SomeCounter.java
----
include::example$replicatedentity-examples/src/main/java/com/example/replicated/counter/domain/SomeCounter.java[tag=update]
----

<1> Modify the Replicated Counter with `increment` or `decrement` and trigger a replicated update by returning an `Effect` with `effects().update`.

The current value of a Replicated Counter can be retrieved using `getValue`:

[source,java,indent=0]
.src/main/java/com/example/replicated/counter/domain/SomeCounter.java
----
include::example$replicatedentity-examples/src/main/java/com/example/replicated/counter/domain/SomeCounter.java[tag=get]
----

<1> Get the current value of a Replicated Counter using `getValue`.

NOTE: The current value may not be the most up-to-date value when there are concurrent modifications.


=== Replicated Register

A link:{attachmentsdir}/api/com/akkaserverless/javasdk/replicatedentity/ReplicatedRegister.html[`ReplicatedRegister` {tab-icon}, window="new"] can contain any (serializable) value. Updates to the value are replicated using last-write-wins semantics, where concurrent modifications are resolved by using the update with the highest timestamp.

ifdef::todo[TODO: configuring clocks for register replication]

To configure a Replicated Entity with a Replicated Register, use the `replicated_register` option when <<_defining_the_proto_files,defining the `proto` file>> for the entity domain:

[source,proto]
.src/main/proto/replicated/register_domain.proto
----
include::example$replicatedentity-examples/src/main/proto/replicated/register_domain.proto[tag=replicated_entity]
----

<1> Specify the Replicated Data type as a Replicated Register.
<2> Specify the `protobuf` message type for the register's value.

When implementing a Replicated Register entity, an initial or empty value needs to be defined by overriding the `emptyValue` method:

[source,java,indent=0]
.src/main/java/com/example/replicated/register/domain/SomeRegister.java
----
include::example$replicatedentity-examples/src/main/java/com/example/replicated/register/domain/SomeRegister.java[tag=emptyValue]
----

The value can be updated by calling the `set` method on the current data object, and then triggering an update with the modified data object:

[source,java,indent=0]
.src/main/java/com/example/replicated/register/domain/SomeRegister.java
----
include::example$replicatedentity-examples/src/main/java/com/example/replicated/register/domain/SomeRegister.java[tag=update]
----

<1> Create a domain object for the new value.
<2> Update the Replicated Register value with `set` and trigger a replicated update by returning an `Effect` with `effects().update`.

The current value of a Replicated Register can be retrieved using `get`:

[source,java,indent=0]
.src/main/java/com/example/replicated/register/domain/SomeRegister.java
----
include::example$replicatedentity-examples/src/main/java/com/example/replicated/register/domain/SomeRegister.java[tag=get]
----

<1> Get the current value of a Replicated Register using `get`.
<2> Convert from the domain object to the API object.

NOTE: The current value may not be the most up-to-date value when there are concurrent modifications.


=== Replicated Set

A link:{attachmentsdir}/api/com/akkaserverless/javasdk/replicatedentity/ReplicatedSet.html[`ReplicatedSet` {tab-icon}, window="new"] is a set of (serializable) values, where elements can be added or removed.

To configure a Replicated Entity with a Replicated Set, use the `replicated_set` option when <<_defining_the_proto_files,defining the `proto` file>> for the entity domain:

[source,proto]
.src/main/proto/replicated/set_domain.proto
----
include::example$replicatedentity-examples/src/main/proto/replicated/set_domain.proto[tag=replicated_entity]
----

<1> Specify the Replicated Data type as a Replicated Set.
<2> Specify the `protobuf` message type for the elements of the set.

IMPORTANT: Care needs to be taken to ensure that the serialized values for elements in the set are stable.

When implementing a Replicated Set entity, the state can be updated by calling the `add` or `remove` methods on the current data object, and then triggering an update with the modified data object:

[source,java,indent=0]
.src/main/java/com/example/replicated/set/domain/SomeSet.java
----
include::example$replicatedentity-examples/src/main/java/com/example/replicated/set/domain/SomeSet.java[tag=update]
----

<1> Create a domain object for the element.
<2> Modify the elements of the Replicated Set with `add` or `remove` and trigger a replicated update by returning an `Effect` with `effects().update`.

The `elements` method for Replicated Set returns a regular `java.util.Set` that can be used to iterate over the current elements:

[source,java,indent=0]
.src/main/java/com/example/replicated/set/domain/SomeSet.java
----
include::example$replicatedentity-examples/src/main/java/com/example/replicated/set/domain/SomeSet.java[tag=get]
----

<1> Iterate over the current elements of a Replicated Set.

NOTE: The current value may not be the most up-to-date view of the set when there are concurrent modifications.


=== Replicated Counter Map

A link:{attachmentsdir}/api/com/akkaserverless/javasdk/replicatedentity/ReplicatedCounterMap.html[`ReplicatedCounterMap` {tab-icon}, window="new"] maps (serializable) keys to replicated counters, where each value can be incremented and decremented.

To configure a Replicated Entity with a Replicated Counter Map, use the `replicated_counter_map` option when <<_defining_the_proto_files,defining the `proto` file>> for the entity domain:

[source,proto]
.src/main/proto/replicated/counter_map_domain.proto
----
include::example$replicatedentity-examples/src/main/proto/replicated/counter_map_domain.proto[tag=replicated_entity]
----

<1> Specify the Replicated Data type as a Replicated Counter Map.
<2> Specify the `protobuf` message type for the keys of the map.

When implementing a Replicated Counter Map entity, the value of an entry can be updated by calling the `increment` or `decrement` methods on the current data object, and then triggering an update with the modified data object. Entries can be removed from the map using the `remove` method.

[source,java,indent=0]
.src/main/java/com/example/replicated/countermap/domain/SomeCounterMap.java
----
include::example$replicatedentity-examples/src/main/java/com/example/replicated/countermap/domain/SomeCounterMap.java[tag=update]
----

<1> Create a domain object for the key.
<2> Modify the values of the Replicated Counter Map with `increment`, `decrement`, or `remove` and trigger a replicated update by returning an `Effect` with `effects().update`.

Individual counters in a Replicated Counter Map can be accessed, or the set of keys can be used to iterate over all counters.

[source,java,indent=0]
.src/main/java/com/example/replicated/countermap/domain/SomeCounterMap.java
----
include::example$replicatedentity-examples/src/main/java/com/example/replicated/countermap/domain/SomeCounterMap.java[tag=get]
----

<1> Create a domain object for the key.
<2> Get the current counter value for a key using `get`.
<3> Iterate over the current entries of a Replicated Counter Map using `keySet`. Note that this may not be the most up-to-date view of the entries when there are concurrent modifications.

NOTE: The `get` method returns a default value of `0L` if the map does not contain the key.

NOTE: Entries may not contain the most up-to-date values for counters when there are concurrent modifications.


=== Replicated Register Map

A link:{attachmentsdir}/api/com/akkaserverless/javasdk/replicatedentity/ReplicatedRegisterMap.html[`ReplicatedRegisterMap` {tab-icon}, window="new"] maps (serializable) keys to replicated registers of (serializable) values. Updates to values are replicated using last-write-wins semantics, where concurrent modifications are resolved by using the update with the highest timestamp.

ifdef::todo[TODO: configuring clocks for register replication]

To configure a Replicated Entity with a Replicated Register Map, use the `replicated_register_map` option when <<_defining_the_proto_files,defining the `proto` file>> for the entity domain:

[source,proto]
.src/main/proto/replicated/register_map_domain.proto
----
include::example$replicatedentity-examples/src/main/proto/replicated/register_map_domain.proto[tag=replicated_entity]
----

<1> Specify the Replicated Data type as a Replicated Register Map.
<2> Specify the `protobuf` message type for the keys of the map.
<3> Specify the `protobuf` message type for the values of the map.

When implementing a Replicated Register Map entity, the value of an entry can be updated by calling the `setValue` method on the current data object, and then triggering an update with the modified data object. Entries can be removed from the map using the `remove` method.

[source,java,indent=0]
.src/main/java/com/example/replicated/registermap/domain/SomeRegisterMap.java
----
include::example$replicatedentity-examples/src/main/java/com/example/replicated/registermap/domain/SomeRegisterMap.java[tag=update]
----

<1> Create a domain object for the key.
<2> Create a domain object for the value.
<3> Modify the values of the Replicated Register Map with `setValue`, or `remove` and trigger a replicated update by returning an `Effect` with `effects().update`.

Individual registers in a Replicated Register Map can be accessed, or the set of keys can be used to iterate over all registers.

[source,java,indent=0]
.src/main/java/com/example/replicated/registermap/domain/SomeRegisterMap.java
----
include::example$replicatedentity-examples/src/main/java/com/example/replicated/registermap/domain/SomeRegisterMap.java[tag=get]
----

<1> Create a domain object for the key.
<2> Get the current register value for a key using `getValue`.
<3> Iterate over the current entries of a Replicated Register Map using `keySet`.

NOTE: The `getValue` method returns an `Optional` for when the map does not contain the given key.

NOTE: Entries may not contain the most up-to-date values for registers when there are concurrent modifications.


=== Replicated Multi-Map

A link:{attachmentsdir}/api/com/akkaserverless/javasdk/replicatedentity/ReplicatedMultiMap.html[`ReplicatedMultiMap` {tab-icon}, window="new"] maps (serializable) keys to replicated sets of (serializable) values, providing a multi-map interface that can associate multiple values with each key.

To configure a Replicated Entity with a Replicated Multi-Map, use the `replicated_multi_map` option when <<_defining_the_proto_files,defining the `proto` file>> for the entity domain:

[source,proto]
.src/main/proto/replicated/multi_map_domain.proto
----
include::example$replicatedentity-examples/src/main/proto/replicated/multi_map_domain.proto[tag=replicated_entity]
----

<1> Specify the Replicated Data type as a Replicated Multi-Map.
<2> Specify the `protobuf` message type for the keys of the multi-map.
<3> Specify the `protobuf` message type for the values of the multi-map.

When implementing a Replicated Multi-Map entity, the values of an entry can be updated by calling the `put`, `putAll`, or `remove` methods on the current data object, and then triggering an update with the modified data object. Entries can be removed entirely from the map using the `removeAll` method.

[source,java,indent=0]
.src/main/java/com/example/replicated/multimap/domain/SomeMultiMap.java
----
include::example$replicatedentity-examples/src/main/java/com/example/replicated/multimap/domain/SomeMultiMap.java[tag=update]
----

<1> Create a domain object for the key.
<2> Create a domain object for the value.
<3> Modify the values of the Replicated Multi-Map with `put`, `putAll`, `remove`, or `removeAll` and trigger a replicated update by returning an `Effect` with `effects().update`.

Individual entries in a Replicated Multi-Map can be accessed, or the set of keys can be used to iterate over all value sets.

[source,java,indent=0]
.src/main/java/com/example/replicated/multimap/domain/SomeMultiMap.java
----
include::example$replicatedentity-examples/src/main/java/com/example/replicated/multimap/domain/SomeMultiMap.java[tag=get]
----

<1> Create a domain object for the key.
<2> Get the current set of values for a key using `get`.
<3> Iterate over the current entries of a Replicated Multi-Map using `keySet`.

NOTE: Entries may not contain the most up-to-date values when there are concurrent modifications.


=== Replicated Map

A link:{attachmentsdir}/api/com/akkaserverless/javasdk/replicatedentity/ReplicatedMap.html[`ReplicatedMap` {tab-icon}, window="new"] maps (serializable) keys to any other Replicated Data types, allowing a heterogeneous map where values can be of any Replicated Data type.

NOTE: Prefer to use the specialized replicated maps (<<_replicated_counter_map>>, <<_replicated_register_map>>, or <<_replicated_multi_map>>) whenever the values of the map are of the same type -- counters, registers, or sets.

To configure a Replicated Entity with a (heterogeneous) Replicated Map, use the `replicated_map` option when <<_defining_the_proto_files,defining the `proto` file>> for the entity domain:

[source,proto]
.src/main/proto/replicated/map_domain.proto
----
include::example$replicatedentity-examples/src/main/proto/replicated/map_domain.proto[tag=replicated_entity]
----

<1> Specify the Replicated Data type as a Replicated Map.
<2> Specify the `protobuf` message type for the keys of the map.

NOTE: The value type for a Replicated Map is not specified for code-generation, and will be set to `ReplicatedData` for a heterogeneous map.

When implementing a Replicated Map entity, the replicated data for an entry can be updated by retrieving the data value using the `get` or `getOrElse` methods, updating values using the `update` method, and then triggering an update effect with the modified Replicated Map. Entries can be removed from the map using the `remove` method.

[source,java,indent=0]
.src/main/java/com/example/replicated/map/domain/SomeMap.java
----
include::example$replicatedentity-examples/src/main/java/com/example/replicated/map/domain/SomeMap.java[tag=update]
----

<1> Get the Replicated Data object for a key using `getOrCreate`, which also takes a function to create an empty value using a `ReplicatedDataFactory`.
<2> Modify the Replicated Data value using its modifying methods and `update` on the Replicated Map.
<3> Trigger a replicated update by returning an `Effect` with `effects().update`.

Individual Replicated Data objects in the Replicated Map can also be accessed for reading the current values.

[source,java,indent=0]
.src/main/java/com/example/replicated/map/domain/SomeMap.java
----
include::example$replicatedentity-examples/src/main/java/com/example/replicated/map/domain/SomeMap.java[tag=get]
----

<1> Get the Replicated Data object for a key using `getOrCreate`, which also takes a function to create an empty value using a `ReplicatedDataFactory`.

NOTE: Entries may not contain the most up-to-date values when there are concurrent modifications.


[IMPORTANT]
====
All objects used within Replicated Data types -- as keys, values, or elements -- must be immutable, and their serialized form must be stable.

Akka Serverless uses the serialized form of these values to track changes in Replicated Sets or Maps. If the same value serializes to different bytes on different occasions, they will be treated as different keys, values, or elements in a Replicated Set or Map.

This is particularly relevant when using Protocol Buffers (`protobuf`) for serialization. The serialized ordering for the entries of a protobuf `map` type is undefined, so protobuf `map` types should not be used within protobuf messages that are keys, values, or elements in Replicated Data objects.

For the rest of the protobuf specification, while no guarantees are made on the stability by the protobuf specification itself, the Java libraries do produce stable orderings for message fields and repeated fields. But care should be taken when changing the protobuf structure of any types used within Replicated Data objects -- many changes that are backwards compatible from a protobuf standpoint do not necessarily translate into stable serializations.
====
