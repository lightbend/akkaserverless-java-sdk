= Actions as Controller
:page-supergroup-java-scala: Language

Actions can be used to implement link:https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller[MVC Controllers] by
acting as the external interface of a service, receiving requests, operating over the requests values and forwarding the call
to other components.

To illustrate how you can use an Action as a Controller, we will build on top of the xref:writing-grpc-descriptors-protobuf.adoc[Value Entity Shopping Cart] example, adding a new Action to the existing shopping cart service.

== Forwarding Commands

The `forward` effect allows us to transform or further validate an incoming request before passing it on to another
component and have the response message directly passed back to the client making the request. The response from the
forwarded operation must have the same response type as the original command.

In this example we accept a Aaaa and turn it into a Bbbb before forwarding it to the shopping cart.

FIXME come up with useful forward example wrt shopping cart.

== Async Replies

The `asyncReply` and `asyncEffect` effects allow us to accept a call, process and transform the request, pass it or a
new request on to another component, and when that component responds also process and transform the response.

As an example, let us look at the problem of creating a new entity with an id generated by the service itself.

In this example we implement a `Initialize` command for the controller Action which returns the message `NewCartCreated`
with the entity id that can subsequently be used to interact with the cart.

[.tabset]
Java::
+
.src/main/java/com/example/shoppingcart/ShoppingCartActionImpl.java
[source,java]
----
include::example$java-valueentity-shopping-cart/src/main/java/com/example/shoppingcart/ShoppingCartActionImpl.java[tag=initialize]
----
<1> We generate a new UUID
<2> We use `components().shoppingCart().create(...)` to create a `DeferredCall` for `create` on the shopping cart
<3> `execute()` on the `DeferredCall` immediately triggers a call and returns a `CompletionStage` for the response
<4> Once the call succeeds or fails the `CompletionStage` is completed or failed, we can transform the result from `CompletionStage<Empty>`
    to `CompletionStage<Effect<NewCartCreated>>` using `handle`.
<5> On a successful response, we create a reply effect with a `NewCartCreated`
<6> If the call leads to an error, we create an error effect asking the client to retry
<7> `effects().asyncEffect()` allows us to reply with a `CompletionStage<Effect<NewCartCreated>>`

Scala::
+
.src/main/java/com/example/shoppingcart/ShoppingCartActionImpl.scala
[source,scala]
----
include::example$scala-valueentity-shopping-cart/src/main/scala/com/example/shoppingcart/ShoppingCartActionImpl.scala[tag=initialize]
----
<1> We generate a new UUID
<2> We use `components.shoppingCart.create(...)` to create a `DeferredCall` for `create` on the shopping cart
<3> `execute()` on the `DeferredCall` immediately triggers a call and returns a `Future` for the response
<4>  On a successful response, we `map` the `Empty` reply to a reply effect with the reply `NewCartCreated`
<5> If the call leads to an error, we `recover` and return an error effect asking the client to retry
<6> `effects.asyncEffect()` allows us to reply with a `Future[Effect[NewCartCreated]]` rather than a reply we already have created

The action generates a UUID to use as entity id for the shopping cart. UUIDs are very unlikely to lead to the same id
being generated, but it is not guaranteed. To make sure two calls can never be assigned the same shopping cart we
depend on the "boundary of consistency" provided by the entity - it will only process a single command at a time
and can safely make decisions based on its state - for example to only allow creation once.

Tracking that the entity has been created is done with a creation timestamp in the shopping cart state, if the cart
has not been created before it will be 0 and we can update the state with a timestamp and return success. If the cart
has already been created the timestamp has a value and we return an error effect.

[.tabset]
Java::
+
.src/main/java/com/example/shoppingcart/domain/ShoppingCart.java
[source,java]
----
include::example$java-valueentity-shopping-cart/src/main/java/com/example/shoppingcart/domain/ShoppingCart.java[tag=create]
----

Scala::
+
.src/main/java/com/example/shoppingcart/domain/ShoppingCart.scala
[source,scala]
----
include::example$scala-valueentity-shopping-cart/src/main/scala/com/example/shoppingcart/domain/ShoppingCart.scala[tag=create]
----


== Aggregate and Compose








add
an Action that will take the incoming `Increase` command, double its value and forward the request to a `Counter` entity.


[.tabset]
Java::
+
[source,proto,indent=0]
.src/main/proto/com/example/actions/double-counter.proto
----
include::example$java-valueentity-counter/src/main/proto/com/example/actions/double-counter.proto[tag=double-action-proto]
----
<1> Import the Counter API definition
<2> The protobuf option (akkaserverless.service) is specific to code-generation as provided by the Akka Serverless Maven plugin. This annotation indicates to the code-generation that an Action must be generated.
<3> The Action mimics the Counter API

Scala::
+
[source,proto,indent=0]
.src/main/proto/com/example/actions/double-counter.proto
----
include::example$scala-valueentity-counter/src/main/proto/com/example/actions/double-counter.proto[tag=double-action-proto]
----
<1> Import the Counter API definition
<2> The protobuf option (akkaserverless.service) is specific to code-generation as provided by the Akka Serverless sbt plugin. This annotation indicates to the code-generation that an Action must be generated.
<3> The Action mimics the Counter API

== Implementing the Action

The class `DoubleCounterAction` gets generated for us based on the proto file defined above.

[.tabset]
Java::
+
[source,java,indent=0]
.src/main/java/com/example/actions/DoubleCounterAction.java
----
include::example$java-valueentity-counter/src/main/java/com/example/actions/DoubleCounterAction.java[tag=controller-forward]
----
<1> On incoming requests, we double the value of `IncreaseValue`
<2> We use `components().counter().increase()` to create a `DeferredCall` that is then passed to `effects().forward()` method.

Scala::
+
[source,scala,indent=0]
.src/main/scala/com/example/actions/DoubleCounterAction.scala
----
include::example$scala-valueentity-counter/src/main/scala/com/example/actions/DoubleCounterAction.scala[tag=controller-forward]
----
<1> On incoming requests, we double the value of `IncreaseValue`
<2> We call `components.counter.increase()` to create a `DeferredCall` that is then passed to `effects.forward()` method.

== Registering the Action

To make Akka Serverless aware of the Action, we need to register it with the service.

From the code-generation, the registration gets automatically inserted in the generated `AkkaServerlessFactory.withComponents` method from the `Main` class.

When we add an Action to an existing service, like we did here, the `Main` class needs to be adapted. In this example, we build on top
of the  xref:value-entity.adoc[Value Entity Counter] example. Therefore, the generated `AkkaServerlessFactory.withComponents` is now accepting
two registrations: the `Counter` and the `DoubleCounterAction`, and we need to adapt it.

[.tabset]
Java::
+
[source,java]
./src/main/java/com/example/Main.java
----
include::example$java-valueentity-counter/src/main/java/com/example/Main.java[tag=registration]
----

Scala::
+
[source,scala]
./src/main/scala/com/example/fibonacci/Main.scala
----
include::example$scala-valueentity-counter/src/main/scala/com/example/Main.scala[tag=registration]
----
