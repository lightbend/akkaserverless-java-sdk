= Run a service locally

include::ROOT:partial$include.adoc[]

Running a service locally is helpful to test and debug. The following sections provide commands for starting and stopping a single service locally.

== Prerequisites

In order to run your service locally, you'll need to have the following prerequisites:

* Docker {minimum_docker_version} or higher
* Access to the `gcr.io/kalix-public` container registry

[TIP]
====
The samples provided with the Kalix SDKs all have `docker-compose` files preconfigured to run your service locally. They also contain the configuration to start a local Google Pub/Sub emulator that the Kalix proxy will connect to when you make use of topic-based Eventing in your service.
====

== Starting your service

To start your service locally, run the following command from the root of your project:

--
[source, command line]
----
mvn kalix:runAll
----
--

This command will start your Kalix service and a Kalix Proxy using the included `docker-compose.yml` file.

If you prefer, you can also start `docker-compose` directly by running `docker-compose up` in one terminal and in another terminal start your Kalix service with:

--
[source, command line]
----
mvn kalix:run
----
--

== Invoking your service

After you start the service it will accept invocations on `localhost:9000`. You can use cURL to invoke your service.

In this example, we assume a customer entity exposing its current state at URL `/customer/\{customerId}` where `customerId` is its unique identifier.

=== Using cURL

--
[source,command line]
----
curl -XGET localhost:9000/customer/001
----
--

== Shut down the service

Use `Ctrl+C` to shutdown the service. When stopping your service, it will also shutdown the Kalix Proxy container and any other container you have defined in `docker-compose.yml`. Unless you have chosen to start `docker-compose` manually in a separate terminal, in which case you will need to stop it manually as well. 

== Running multiple services locally

A typical Kalix application is composed of one or more services deployed to the same Kalix project. When deployed under the same Kalix project, two different services can make xref:call-another-service.adoc[calls to each other] or xref:service-to-service.adoc[subscribe to each other event streams] by simply using their logical names.

The same can be done on your local machine by configuring the services to run on different ports and by configuring them to "_discover_" each other using some extra configurations. 

In this section we will show you how to configure your local development environment to run two services and having then calling each other.
For that we will use two of our existing samples: https://github.com/lightbend/kalix-jvm-sdk/tree/main/samples/java-spring-eventsourced-customer-registry[`customer-registry`] and https://github.com/lightbend/kalix-jvm-sdk/tree/main/samples/java-spring-eventsourced-customer-registry-subscriber[`customer-registry-subscriber`]. 

The *customer-registry* sample provides a service to register customers and the *customer-registry-subscriber* subscribes to an event stream produced by the *customer-registry* service and build a xref:views.adoc[View] from it.

=== Customer Registry Sample

The `docker-compose.yml` file from *customer-registry* is left untouched and use the usual default ports. The user function will run on port 8080 and the Kalix Proxy on port 9000.

[source,yml,indent=0]
----
include::java:example$java-spring-eventsourced-customer-registry/docker-compose.yml[tag=customer-registry]
----

=== Customer Registry Subscriber Sample

On the other hand, in the *customer-registry-subscriber* we will use port 8081 and 9001 respectively to avoid port conflicts with the *customer-registry* service.

Moreover, since *customer-registry-subscriber* needs to subscribe to *customer-registry* and since we will be running it on our local machine, we need to _teach_ it where to find the *customer-registry* service.

This is done by passing an extra property (`kalix.dev-mode.service-port-mappings.customer-registry`) to its Kalix Proxy to let it create a mapping between the logical name *customer-registry* and the host and port where the *customer-registry* service is running.

Note that you need to add service port mappings to the Kalix Proxy configuration for the service that depends on the other service. Here, *customer-registry-subscriber* depends on *customer-registry*, therefore we add the service port mapping to the Kalix Proxy associated to *customer-registry-subscriber*.

[source,yml,indent=0]
----
include::java:example$java-spring-eventsourced-customer-registry-subscriber/docker-compose.yml[tag=customer-registry-subscriber]
----

With both services configured, we can start them independently by running `mvn kalix:runAll` in two disinct terminals. 

From a third terminal, we can create a customer on *customer-registry* service.

```shell
curl localhost:9000/customer/one/create \
  --header "Content-Type: application/json" \
  -XPOST \
  --data '{"email":"test@example.com","name":"Test","address":{"street":"Test street 25","city":"Test City"}}'
```

While watching the logs in *customer-registry-subscriber* service, we will see it receiving the customer created event. After that we can query its View.

```shell
curl localhost:9001/customers/by_name/Test
```

== Running multiple services with Docker

Another alternative is to build a larger `docker-compose` file containing dependent services. 

In the case of *customer-registry-subscriber*, we can have a second `docker-compose` file containing a Kalix Proxy for *customer-registry-subscriber*, a Kalix Proxy for *customer-registry* and the *customer-registry* itself. 

[source,yml,indent=0]
----
include::java:example$java-spring-eventsourced-customer-registry-subscriber/docker-compose-integration.yml[tag=customer-registry-docker]
----

First we need to build a image for *customer-registry*. For this exercise, we don't need to publish it to a remote container registry. It suffice to build it locally. 

We can build the image by calling the following command at the root of  *customer-registry*:

```shell
mvn package docker:build
```

Next we can run *customer-registry-subscriber* and instead pass `docker-compose-integration.yml` to it. 

Run the following command at the root of *customer-registry-subscriber*:

```shell
mvn -Dkalix.dev-mode.docker-compose-file=docker-compose-integration.yml kalix:runAll
```

This time, `kalix:runAll` will start `docker-compose-integration.yml` instead. The *customer-registry* service and its companion Kalix Proxy will run alongside *customer-registry-subscriber*. 

Note that the configuraiton is exactly the same except that now we are running one single `kalix:runAll` command and the docker-compose file we are using contain all the dependencies required by *customer-registry-subscriber*.
