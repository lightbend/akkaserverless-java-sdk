= Calling other Akka Serverless services

// FIXME this does not actually work (yet?) https://github.com/lightbend/akkaserverless-docs/issues/903#issuecomment-919174111

// FIXME possible from the same project only?
In some cases it is useful to call a component in another service, for example to write logic that touches multiple entities or actions, to aggregate their return values or perform a multi-step workflow.

Calling other Akka Serverless services from an Action is done by invoking them over gRPC much like how an external client would. The service is however identified by its service name and encrypting the communication using TLS is handled for us by Akka Serverless.

It is possible to use any gRPC client you want, but since Akka gRPC is already used by the SDK we recommend using it.

Since the proto file of an Akka Serverless service contains annotations that cause the Java SDK code generation to generate services we need to start by removing those. Copy the API definition proto file from the other service into the `proto` directory but strip all `akkaserverless.service` option blocks as well as all other Akka Serverless annotations and the `import "akkaserverless/annotations.proto"` from it.

The build needs to be updated to generate Akka gRPC client classes. In the existing configuration for the `protobuf-maven-plugin` in your `pom.xml` add the following:

---
// FIXME this block is a bit unwieldy, but har to understand where/what to add if not
// FIXME should we _always_ include something instead, like a src/main/ex-proto and avoid clients for the service itself?
```xml
<plugin>
  <groupId>org.xolstice.maven.plugins</groupId>
  <artifactId>protobuf-maven-plugin</artifactId>
  <version>0.6.1</version>
    <executions>
      <execution>
        <!-- generate Java code for protobuf types -->
        <id>protobuf</id>
        <goals>
          <goal>compile</goal>
        </goals>
        <configuration>
          <writeDescriptorSet>true</writeDescriptorSet>
          <includeSourceInfoInDescriptorSet>true</includeSourceInfoInDescriptorSet>
          <descriptorSetFileName>user-function.desc</descriptorSetFileName>
          <checkStaleness>true</checkStaleness>
          <protocArtifact>com.google.protobuf:protoc:3.9.1:exe:${os.detected.classifier}</protocArtifact>
          <!-- add this block --> // <1>
          <protocPlugins>
            <protocPlugin>
              <id>akka-grpc</id>
              <groupId>com.lightbend.akka.grpc</groupId>
              <artifactId>akka-grpc-scalapb-protoc-plugin_2.12</artifactId>
              <version>${akka-grpc.version}</version>
              <mainClass>akka.grpc.gen.Main</mainClass>
            </protocPlugin>
          </protocPlugins>
          <!-- end of block to add -->
        </configuration>
      </execution>
   </executions>
</plugin>
```
---
<1> The `protocPlugins` block to add

The Akka gRPC `protocPlugin` will now generate Akka gRPC client classes for the service when we compile it.

To use the generated client we need to manually create an instance for it:

// FIXME this leaks clients as a Action is created on each call, we either need to inject it and share or create a new one and close it for every call (but I think we'd want to re-use rather?)
// FIXME withTls(false) doesn't seem to work
// FIXME host/port should probably come from config? Or do we keep sample brief and just mention that instead?
---
```java
/** An action. */
public class ProxyAction extends AbstractProxyAction {

  private final CounterServiceClient counterClient;

  public ProxyAction(ActorSystem system, ActionCreationContext creationContext) { // <1>
    // Configure the client by code:
    GrpcClientSettings settings =
        GrpcClientSettings.connectToServiceAt("my-service", 80, system) // <2>
          .withTls(false); // <3>
    counterClient = CounterServiceClient.create(settings, system);
  }
}
```
---
// FIXME actor system is messy - where do they get it from, create their own, in tests etc?
<1> We need an Akka `ActorSystem` which we inject from the project main
<2> Use the name of the service and port 80 to connect to it
<3> Disable TLS as that is handled by Akka Serverless

Then in an action method we can use the client:

---
```java
  @Override
  public Effect<ProxyApi.IncreaseResult> proxiedIncreaseCounter(Empty empty) {
    // increase the counter <1>
    CompletionStage<Empty> increaseCompleted = counterClient.increase(CounterApi.IncreaseValue.newBuilder()
        .setValue(1)
        .setCounterId("the-counter")
        .build());

    CompletionStage<CounterApi.CurrentCounter> currentCounterValueAfter = increaseCompleted.thenCompose((__) -> // <2>
        // once increase completed successfully, ask for the current state after
        counterClient.getCurrentCounter(CounterApi.GetCounter.newBuilder().setCounterId("the-counter").build())
    );

    // turn the reply from the other service into our reply type
    CompletionStage<ProxyApi.IncreaseResult> result = currentCounterValueAfter.thenApply(currentCounter -> // <3>
        ProxyApi.IncreaseResult.newBuilder().setValue(currentCounter.getValue()).build());

    return effects().asyncReply(result); // <4>
  }
```
---
<1> Calling a unary gRPC method returns a "future" value in a `CompletionStage`. When execution continues through our method, the result will likely not yet have "completed" the future.
<2> To use the reply value we register a callback to execute once it completes, here we ignore the response and call the `getCurrentCounter` method once the update has completed, to make the two calls _sequential_.
<3> Once we get a response for the `getCurrentCounter` we transform that into a `IncreasedResult` - the response type of this action method.
<4> We can reply with a `CompletionStage<IncreasedResult>` using `effects().asyncReply`. Once the `CompletionStage` completes, the client will get the response back.


For additional documentation about Akka gRPC see the https://doc.akka.io/docs/akka-grpc/current/index.html[Akka gRPC documentation].


