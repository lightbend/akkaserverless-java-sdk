= Implementing Event Sourced Entities with Spring
:page-aliases: spring:eventsourced.adoc
:page-supergroup-java-scala: Language

include::ROOT:partial$include.adoc[]
include::ROOT:partial$eventsourced.adoc[]

https://docs.kalix.io/reference/glossary.html#event_sourced_entity[Event Sourced Entities] persist changes as events and snapshots. Kalix needs to serialize that data to send it to the underlying data store. However, we recommend that you do not persist your service's public API messages. This may introduce some overhead to convert from one type to an internal one but allows the service public interface logic to evolve independently of the data storage format, which should be private.

The steps necessary to implement an Event Sourced Entity include:

. Model the entity's state and its domain events.
. Implementing behavior in command and event handlers.
. Creating and initializing the Entity.


The following sections walk through these steps using a shopping cart service as an example.

== Model the entity

NOTE: Our Event Sourced Entity example is a shopping cart service.

Through our "Shopping Cart" Event Sourced Entity we expect to manage our cart, adding and removing items as we please. Being event-sourced means it will represent changes to state as a series of domain events. So let's have a look at what kind of model we expect to store for our shopping and the events our entity might generate.

Spring-sdk::
+
[source,java]
.src/main/java/com/example/shoppingcart/domain/ShoppingCart.java
----
include::example$spring-eventsourced-shopping-cart/src/main/java/com/example/shoppingcart/domain/ShoppingCart.java[tag=domain]
----
<1> Our `ShoppingCart` is fairly simple, being composed only by a `cartId` and a list of line items.
<2> A `LineItem` represents a single product and the quantity we pretend to buy.

NOTE: Above we are taking advantage of the fairly recent Java `record` to reduce the amount of boilerplate code, but you can use regular classes so long as they can be serialized.

Another fundamental aspect of our entity will be its domain events. For now, we will have two different events `ItemAdded` and `ItemRemoved`, defined as below:

Spring-sdk::
+
[source,java]
.src/main/java/com/example/shoppingcart/domain/ShoppingCart.java
----
include::example$spring-eventsourced-shopping-cart/src/main/java/com/example/shoppingcart/domain/ShoppingCartEvent.java[tag=events]
----
<1> TODO

== Implementing behavior

// TODO make a note somewhere that the component is automatically discovered

An Event Sourced Entity is a class where you define how each command is handled. Now that we have our Entity state defined along with its events, let's see how to take advantage of them to actually create such an entity:

Spring-sdk::
+
[source,java]
.src/main/java/com/example/shoppingcart/ShoppingCartService.java
----
include::example$spring-eventsourced-shopping-cart/src/main/java/com/example/shoppingcart/ShoppingCartService.java[tag=class]
----
<1> create a class that extends `EventSourcedEntity<S>`, where `S` is the state type this entity will store (i.e. `ShoppingCart`)
<2> make sure to annotate such class with `@Entity` and pass in an `entityKey` and an `entityType`
<3> make use of Spring's RequestMapping annotation to define the routes to your service
<4> declare the methods that will handle the requests/commands and emit the outgoing events
<5> define the methods that will serve as handlers of the events generated by the commands by marking such methods with `@EventHandler`

From the above example, note that:

- `entityKey` and `entityKey` have the same semantics as previously explained for Value Entities
- the `emptyState()` override is optional. If not using it, be careful to deal with a currentState() with a `null` value when receiving the first command
- there needs to be one event handler declared per each type of event the ES entity emits (e.g `handleIncrease` receives a param of type `ValueIncreased`, the same type emitted in `increase` command handler)





=== Updating state

In the example below, the `AddItem` service call uses the request message `AddLineItem`. It returns an `Effect` to emit an event and then sends a reply once the event is stored successfully. The state is updated by the event handler.

IMPORTANT: The **only** way for a command handler to modify the Entity's state is by emitting an event. Any modifications made directly to the state (or instance variables) from the command handler are not persisted. When the Entity is passivated and reloaded, those modifications will not be present.

Spring-sdk::
+
[source,java,indent=0]
.src/main/java/com/example/shoppingcart/domain/ShoppingCart.java
----
include::example$java-eventsourced-shopping-cart/src/main/java/com/example/shoppingcart/domain/ShoppingCart.java[tag=addItem]
----
<1> The validation ensures the quantity of items added is greater than zero and it fails calls with illegal values by returning an `Effect` with `effects().error`.
<2> From the current incoming `AddLineItem` we create a new `ItemAdded` event representing the change of the cart.
<3> We store the event by returning an `Effect` with `effects().emitEvent`.
<4> The acknowledgment that the command was successfully processed is only sent if the event was successfully stored, otherwise there will be an error reply.


=== Retrieving state

The following example shows the implementation of the `GetCart` command handler. This command handler is a read-only command handler--it doesn't update the state, it just returns it:

Java::
+
[source,java,indent=0]
.src/main/java/com/example/shoppingcart/domain/ShoppingCart.java
----
include::example$java-eventsourced-shopping-cart/src/main/java/com/example/shoppingcart/domain/ShoppingCart.java[tag=getCart]
----
<1> The current state is passed to the method.
<2> We convert the domain representation to the API representation that is sent as a reply by returning an `Effect` with `effects().reply`.


== Snapshots

Snapshots are an important optimization for Event Sourced Entities that emit many events. Rather than reading the entire journal upon loading or restart, Kalix can initiate them from a snapshot.

Snapshots are stored and handled automatically by Kalix without any specific code required. Snapshots are stored after a configured number of events:

[source,conf,indent=0]
.src/main/resources/application.conf
----
include::example$java-eventsourced-shopping-cart/src/main/resources/application.conf[tag=snapshot-every]
----

When the Event Sourced Entity is loaded again, the snapshot will be loaded before any other events are received.

== Testing the Entity
