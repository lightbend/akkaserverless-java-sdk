/*
 * Copyright 2021 Lightbend Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.lightbend.akkasls.codegen.java

import _root_.java.nio.file.{Files, Path, Paths}
import _root_.java.io.File
import com.google.common.base.Charsets
import org.bitbucket.inkytonik.kiama.output.PrettyPrinter

import scala.collection.immutable
import com.lightbend.akkasls.codegen._
import com.lightbend.akkasls.codegen.DescriptorSet
import com.lightbend.akkasls.codegen.Log
import com.lightbend.akkasls.codegen.ModelBuilder
import com.lightbend.akkasls.codegen.ModelBuilder.{Command, Entity, Service, State}

/**
 * Responsible for generating Java source from an entity model
 */
object SourceGenerator extends PrettyPrinter {

  /**
   * Generate Java source from entities where the target source and test source directories have no existing source.
   * Note that we only generate tests for entities where we are successful in generating an entity. The user may
   * not want a test otherwise.
   *
   * Also generates a main source file if it does not already exist.
   *
   * Impure.
   *
   * @param model The model of entity metadata to generate source file
   * @param sourceDirectory A directory to generate source files in, which can also containing existing source.
   * @param testSourceDirectory A directory to generate test source files in, which can also containing existing source.
   * @param integrationTestSourceDirectory A directory to generate integration test source files in, which can also containing existing source.
   * @param mainClass  A fully qualified classname to be used as the main class
   * @return A collection of paths addressing source files generated by this function
   */
  def generate(
      model: ModelBuilder.Model,
      sourceDirectory: Path,
      testSourceDirectory: Path,
      integrationTestSourceDirectory: Path,
      generatedSourceDirectory: Path,
      mainClass: String
  )(implicit log: Log): Iterable[Path] = {

    val (mainClassPackageName, mainClassName) = disassembleClassName(mainClass)

    model.services.values.flatMap {
      case service: ModelBuilder.EntityService =>
        model.entities.get(service.componentFullName) match {
          case None =>
            // TODO perhaps we even want to make this an error, to really go all-in on codegen?
            log.warning(
              "Service [" + service.fqn.fullName + "] refers to entity [" + service.componentFullName +
              "], but no entity configuration is found for that component name"
            )
            Seq.empty
          case Some(entity) =>
            EntityServiceSourceGenerator.generate(
              entity,
              service,
              sourceDirectory,
              testSourceDirectory,
              integrationTestSourceDirectory,
              generatedSourceDirectory,
              mainClassPackageName,
              mainClassName
            )
        }
      case service: ModelBuilder.ViewService if service.transformedUpdates.nonEmpty =>
        ViewServiceSourceGenerator.generate(
          service,
          sourceDirectory,
          testSourceDirectory,
          integrationTestSourceDirectory,
          generatedSourceDirectory,
          mainClassPackageName,
          mainClassName
        )
      case service: ModelBuilder.ActionService =>
        ActionServiceSourceGenerator.generate(
          service,
          sourceDirectory,
          testSourceDirectory,
          integrationTestSourceDirectory,
          generatedSourceDirectory,
          mainClassPackageName,
          mainClassName
        )
      case _ => Seq.empty
    } ++ {
      val mainClassPackagePath = packageAsPath(mainClassPackageName)

      val mainComponentRegistrationsClassName = mainClassName + "ComponentRegistrations"
      val mainComponentRegistrationsSourcePath =
        generatedSourceDirectory.resolve(
          mainClassPackagePath.resolve(mainComponentRegistrationsClassName + ".java")
        )

      mainComponentRegistrationsSourcePath.getParent.toFile.mkdirs()
      Files.write(
        mainComponentRegistrationsSourcePath,
        mainComponentRegistrationsSource(mainClassPackageName, mainClassName, model).getBytes(Charsets.UTF_8)
      )

      // Generate a main source file if it is not there already

      val mainClassPath =
        sourceDirectory.resolve(mainClassPackagePath.resolve(mainClassName + ".java"))
      if (!mainClassPath.toFile.exists()) {
        mainClassPath.getParent.toFile.mkdirs()
        Files.write(
          mainClassPath,
          mainSource(mainClassPackageName, mainClassName, model.entities).getBytes(Charsets.UTF_8)
        )
        List(mainComponentRegistrationsSourcePath, mainClassPath)
      } else {
        List(mainComponentRegistrationsSourcePath)
      }
    }
  }

  def generate(protobufDescriptor: File,
               sourceDirectory: Path,
               testSourceDirectory: Path,
               integrationTestSourceDirectory: Path,
               generatedSourceDirectory: Path,
               mainClass: String)(implicit log: Log): Iterable[Path] = {
    val descriptors =
      DescriptorSet.fileDescriptors(protobufDescriptor) match {
        case Right(fileDescriptors) =>
          fileDescriptors match {
            case Right(files) => files
            case Left(failure) =>
              throw new RuntimeException(
                s"There was a problem building the file descriptor from its protobuf: $failure"
              )
          }
        case Left(failure) =>
          throw new RuntimeException(s"There was a problem opening the protobuf descriptor file ${failure}", failure.e)
      }

    SourceGenerator.generate(
      ModelBuilder.introspectProtobufClasses(descriptors),
      sourceDirectory,
      testSourceDirectory,
      integrationTestSourceDirectory,
      generatedSourceDirectory,
      mainClass
    )

  }

  def collectRelevantTypes(fullQualifiedNames: Iterable[FullyQualifiedName],
                           service: FullyQualifiedName): immutable.Seq[FullyQualifiedName] = {
    fullQualifiedNames.filterNot { desc =>
      desc.parent == service.parent
    }.toList
  }

  def collectRelevantTypeDescriptors(fullQualifiedNames: Iterable[FullyQualifiedName],
                                     service: FullyQualifiedName): String = {
    collectRelevantTypes(fullQualifiedNames, service)
      .map(desc => s"${desc.parent.javaOuterClassname}.getDescriptor()")
      .distinct
      .sorted
      .mkString(",\n")
  }

  private[codegen] def mainComponentRegistrationsSource(
      mainClassPackageName: String,
      mainClassName: String,
      model: ModelBuilder.Model
  ): String = {

    val registrations = model.services.values.flatMap {
      case service: ModelBuilder.EntityService =>
        model.entities.get(service.componentFullName).toSeq.map {
          case entity: ModelBuilder.EventSourcedEntity =>
            val relevantTypes =
              service.commands.flatMap { cmd =>
                cmd.inputType :: cmd.outputType :: Nil
              } ++ entity.events.map(_.fqn) ++ entity.state.map(_.fqn)

            s"""|.registerEventSourcedEntity(
                |    ${entity.fqn.name}.class,
                |    ${service.fqn.parent.javaOuterClassname}.getDescriptor().findServiceByName("${service.fqn.name}"),
                |    ${Syntax.indent(collectRelevantTypeDescriptors(relevantTypes, service.fqn), 4)}
                |)""".stripMargin

          case entity: ModelBuilder.ValueEntity =>
            s".register(new ${entity.fqn.name}Provider(create${entity.fqn.name}))"
        }

      case service: ModelBuilder.ViewService =>
        val relevantTypes =
          service.commands.flatMap { cmd =>
            cmd.inputType :: cmd.outputType :: Nil
          }

        List(
          s"""|.registerView(
              |    ${service.fqn.name}.class,
              |    ${service.fqn.parent.javaOuterClassname}.getDescriptor().findServiceByName("${service.fqn.name}"),
              |    "${service.viewId}",
              |    ${Syntax.indent(collectRelevantTypeDescriptors(relevantTypes, service.fqn), 4)}
              |)""".stripMargin
        )

      case service: ModelBuilder.ActionService =>
        val relevantTypes =
          service.commands.flatMap { cmd =>
            cmd.inputType :: cmd.outputType :: Nil
          }

        List(
          s"""
           |.registerAction(
           |    ${service.fqn.name}.class,
           |    ${service.fqn.parent.javaOuterClassname}.getDescriptor().findServiceByName("${service.fqn.name}"),
           |    ${Syntax.indent(collectRelevantTypeDescriptors(relevantTypes, service.fqn), 4)}
           |)
           |""".stripMargin
        )

    }.toList

    val entityImports = model.entities.values.flatMap { ety =>
      if (ety.fqn.parent.javaPackage != mainClassPackageName) {
        val imports =
          ety.fqn.fullName ::
          s"${ety.fqn.parent.javaPackage}.${ety.fqn.parent.javaOuterClassname}" ::
          Nil
        ety match {
          // FIXME: for now, we only have Provider for ValueEntity
          case _: ModelBuilder.ValueEntity =>
            s"${ety.fqn.fullName}Provider" :: imports
          case _ => imports
        }
      } else List.empty
    }

    val serviceImports = model.services.values.flatMap { serv =>
      if (serv.fqn.parent.javaPackage != mainClassPackageName)
        serv.fqn.fullName :: s"${serv.fqn.parent.javaPackage}.${serv.fqn.parent.javaOuterClassname}" :: Nil
      else List.empty
    }

    val otherImports = model.services.values.flatMap { serv =>
      val types = serv.commands.flatMap { cmd =>
        cmd.inputType :: cmd.outputType :: Nil
      }
      collectRelevantTypes(types, serv.fqn)
        .collect {
          case typ if typ.parent.javaMultipleFiles =>
            s"${typ.parent.javaPackage}.${typ.parent.javaOuterClassname}"
        }
    }

    val contextImports = model.entities.values
      .collect {
        case _: ModelBuilder.ValueEntity =>
          List(
            "com.akkaserverless.javasdk.valueentity.ValueEntityContext",
            "java.util.function.Function"
          )
      }
      .flatten
      .toSet

    val creatorParameters =
      "AkkaServerless akkaServerless" +: model.entities.values.collect {
        case valueEntity: ModelBuilder.ValueEntity =>
          s"Function<ValueEntityContext, ${valueEntity.fqn.name}> create${valueEntity.fqn.name}"
      }.toList

    val imports =
      (List("com.akkaserverless.javasdk.AkkaServerless") ++ entityImports ++ serviceImports ++ otherImports ++ contextImports).distinct.sorted
        .map(pkg => s"import $pkg;")
        .mkString("\n")

    s"""|$managedCodeCommentString
        |
        |package $mainClassPackageName;
        |
        |$imports
        |
        |public final class ${mainClassName}ComponentRegistrations {
        |
        |  public static AkkaServerless registerAll(${creatorParameters.mkString(",\n      ")}) {
        |    return akkaServerless
        |      ${Syntax.indent(registrations, 6)};
        |  }
        |}""".stripMargin
  }

  private[codegen] def mainSource(
      mainClassPackageName: String,
      mainClassName: String,
      entities: Map[String, Entity]
  ): String = {
    val componentImports = generateImports(Iterable.empty, mainClassPackageName, entities.values.collect {
      case valueEntity: ModelBuilder.ValueEntity => valueEntity.fqn.fullName
    }.toSeq)
    val registrationParameters = "new AkkaServerless()" +: entities.values.collect {
        case valueEntity: ModelBuilder.ValueEntity =>
          s"${valueEntity.fqn.name}::new"
      }.toList

    s"""|$generatedCodeCommentString
        |
        |package $mainClassPackageName;
        |
        |import com.akkaserverless.javasdk.AkkaServerless;
        |import org.slf4j.Logger;
        |import org.slf4j.LoggerFactory;
        |${componentImports}
        |import static ${mainClassPackageName}.${mainClassName}ComponentRegistrations.registerAll;
        |
        |public final class ${mainClassName} {
        |
        |  private static final Logger LOG = LoggerFactory.getLogger(${mainClassName}.class);
        |
        |  public static final AkkaServerless SERVICE =
        |    // This withGeneratedComponentsAdded wrapper automatically registers any generated Actions, Views or Entities,
        |    // and is kept up-to-date with any changes in your protobuf definitions.
        |    // If you prefer, you may remove this wrapper and manually register these components.
        |    registerAll(${registrationParameters.mkString(",\n      ")});
        |
        |  public static void main(String[] args) throws Exception {
        |    LOG.info("starting the Akka Serverless service");
        |    SERVICE.start();
        |  }
        |}""".stripMargin

  }

  private def disassembleClassName(fullClassName: String): (String, String) = {
    val className = fullClassName.reverse.takeWhile(_ != '.').reverse
    val packageName = fullClassName.dropRight(className.length + 1)
    packageName -> className
  }

  private[java] def `interface`(modifier: Doc, name: String)(body: Doc): Doc =
    modifier <+> "interface" <+> name <+>
    braces(nest(line <> body) <> line)

  private[java] def `class`(modifier: Doc, name: String)(body: Doc): Doc =
    `class`(modifier, name, None)(body)

  private[java] def `class`(modifier: Doc, name: String, extension: String)(body: Doc): Doc =
    `class`(modifier, name, Some(extension))(body)

  private[java] def `class`(modifier: Doc, name: String, extension: Option[String])(
      body: Doc
  ): Doc =
    modifier <+> "class" <+> name <+>
    extension.fold(emptyDoc)(ext => "extends" <+> ext <> space) <>
    braces(nest(line <> body) <> line)

  private[java] def constructor(
      modifier: Doc,
      name: String,
      parameters: immutable.Seq[Doc]
  )(body: Doc): Doc =
    modifier <+> name <> parens(ssep(parameters, comma <> space)) <+>
    braces(nest(line <> body) <> line)

  private[java] def method(
      modifier: Doc,
      returnType: Doc,
      name: String,
      parameters: immutable.Seq[Doc],
      postModifier: Doc
  )(body: Doc): Doc =
    modifier <+> returnType <+> name <> parens(ssep(parameters, comma <> space)) <+> postModifier <>
    braces(nest(line <> body) <> line)

  private[java] def field(
      modifier: Doc,
      fieldType: Doc,
      name: String,
      assignmentSeparator: Option[Doc]
  )(assignment: Doc): Doc =
    modifier <+> fieldType <+> name <> (assignmentSeparator match {
      case Some(separator) =>
        space <> equal <> separator <> nest(assignment)
      case None => emptyDoc
    })

  private[java] def abstractMethod(
      modifier: Doc,
      returnType: Doc,
      name: String,
      parameters: immutable.Seq[Doc]
  ): Doc =
    modifier <+> "abstract" <+> returnType <+> name <> parens(ssep(parameters, comma <> space))

  private[java] def qualifiedType(fullyQualifiedName: FullyQualifiedName): String =
    if (fullyQualifiedName.parent.javaMultipleFiles) fullyQualifiedName.name
    else s"${fullyQualifiedName.parent.javaOuterClassname}.${fullyQualifiedName.name}"

  private[java] def typeImport(fullyQualifiedName: FullyQualifiedName): String = {
    val name =
      if (fullyQualifiedName.parent.javaMultipleFiles) fullyQualifiedName.name
      else fullyQualifiedName.parent.javaOuterClassname
    s"${fullyQualifiedName.parent.javaPackage}.$name"
  }

  private[java] def lowerFirst(text: String): String =
    text.headOption match {
      case Some(c) => c.toLower.toString + text.drop(1)
      case None => ""
    }

  private[java] def notImplementedError(handlerType: String, fqn: FullyQualifiedName) = dquotes(
    "The" <+> handlerType <+> "handler for `" <> fqn.name <> "` is not implemented, yet"
  )

  private[java] def packageAsPath(packageName: String): Path =
    Paths.get(packageName.replace(".", "/"))

  private[java] val initialisedCodeComment: Doc =
    "/*" <+> "This code was initialised by Akka Serverless tooling." <> line <>
    " *" <+> "As long as this file exists it will not be re-generated." <> line <>
    " *" <+> "You are free to make changes to this file." <> line <>
    " */"

  private[java] val managedCodeComment: Doc =
    "/*" <+> "This code is managed by Akka Serverless tooling." <> line <>
    " *" <+> "It will be re-generated to reflect any changes to your protobuf definitions." <> line <>
    " *" <+> "DO NOT EDIT" <> line <>
    " */"

  private[java] val generatedCodeCommentString: String =
    s"""|/* This code was generated by Akka Serverless tooling.
        | * As long as this file exists it will not be re-generated.
        | * You are free to make changes to this file.
        | */""".stripMargin

  private[java] val managedCodeCommentString: String =
    s"""|/* This code is managed by Akka Serverless tooling.
        | * It will be re-generated to reflect any changes to your protobuf definitions.
        | * DO NOT EDIT
        | */""".stripMargin

  private[codegen] def generateImports(types: Iterable[FullyQualifiedName],
                                       packageName: String,
                                       otherImports: Seq[String]): String = {
    val messageTypeImports = types
      .filterNot { typ =>
        typ.parent.javaPackage == packageName
      }
      .map(typeImport)

    (messageTypeImports ++ otherImports).toSeq.distinct.sorted
      .map(pkg => s"import $pkg;")
      .mkString("\n")
  }

  private[codegen] def generateImports(commands: Iterable[Command],
                                       state: Option[State],
                                       packageName: String,
                                       otherImports: Seq[String]): String = {

    val types = state.map(_.fqn) ++ commands.flatMap(command => Seq(command.inputType, command.outputType))
    generateImports(types, packageName, otherImports)
  }
}
