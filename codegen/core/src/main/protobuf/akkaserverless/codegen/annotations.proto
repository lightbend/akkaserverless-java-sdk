// Copyright 2021 Lightbend Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// All extension points for Akka Serverless

syntax = "proto3";

package akkaserverless.codegen;

option java_package = "com.akkaserverless";
option java_outer_classname = "CodegenProto";
import "google/protobuf/descriptor.proto";

message CodegenOptions {
  oneof component {
    EventSourcedEntityDef event_sourced_entity = 1;
    // Value entity configuration.
    ValueEntityDef value_entity = 2;
    // Replicated entity configuration.
    ReplicatedEntityDef replicated_entity = 3;
    ActionDef action = 4;
    ViewDef view = 5;
  }
}

extend google.protobuf.ServiceOptions {
  CodegenOptions component = 1081;
}


// Options to describe an Action
message ActionDef {
  string package_name = 1;
  // Optional name for the view - if not defined, will follow the name of the service
  string name = 2;
}

// Options to describe a View
message ViewDef {
  string package_name = 1;
  // Optional name for the view - if not defined, will follow the name of the service
  string name = 2;
}

// Options to describe event sourced entities
message EventSourcedEntityDef {
  string package_name = 1;
  // A mandatory name for the entity - used for type name generation
  string name = 2;
  // A mandatory key name to be used for persisting names with, quite often
  // the name of the entity.
  string entity_type = 3;
  // The associated state message.
  string state = 4;
  // Zero or more event messages associated with the entity.
  repeated string events = 5;
}

// Options to describe value entities
message ValueEntityDef {
  string package_name = 1;
  // A mandatory name for the entity - used for type name generation
  string name = 2;
  // A mandatory key name to be used for persisting names with, quite often
  // the name of the entity.
  string entity_type = 3;
  // The associated state message.
  string state = 4;
}

// Options to describe replicated entities
message ReplicatedEntityDef {
  string package_name = 1;
  // A mandatory name for the entity - used for code generation
  string name = 2;
  // The entity type name used when replicating this entity
  string entity_type = 3;
  // Mandatory replicated data type for this replicated entity
  oneof replicated_data {
    // Configure this entity as a replicated counter
    ReplicatedCounter replicated_counter = 4;
    // Configure this entity as a replicated register
    ReplicatedRegister replicated_register = 5;
    // Configure this entity as a replicated set
    ReplicatedSet replicated_set = 6;
    // Configure this entity as a (heterogeneous) replicated map
    ReplicatedMap replicated_map = 7;
    // Configure this entity as a replicated counter map
    ReplicatedCounterMap replicated_counter_map = 8;
    // Configure this entity as a replicated register map
    ReplicatedRegisterMap replicated_register_map = 9;
    // Configure this entity as a replicated multi-map
    ReplicatedMultiMap replicated_multi_map = 10;
    // Configure this entity as a replicated vote
    ReplicatedVote replicated_vote = 11;
  }
}

// Options specific to replicated counters
message ReplicatedCounter {}

// Options specific to replicated registers
message ReplicatedRegister {
  // Mandatory value type for this replicated register
  string value = 1;
}

// Options specific to replicated sets
message ReplicatedSet {
  // Mandatory element type for this replicated set
  string element = 1;
}

// Options specific to (heterogeneous) replicated maps
message ReplicatedMap {
  // Mandatory key type for this replicated map
  string key = 1;
}

// Options specific to replicated counter maps
message ReplicatedCounterMap {
  // Mandatory key type for this replicated counter map
  string key = 1;
}

// Options specific to replicated register maps
message ReplicatedRegisterMap {
  // Mandatory key type for this replicated register map
  string key = 1;
  // Mandatory value type for this replicated register map
  string value = 2;
}

// Options specific to replicated multi-maps
message ReplicatedMultiMap {
  // Mandatory key type for this replicated multi-map
  string key = 1;
  // Mandatory value type for this replicated multi-map
  string value = 2;
}

// Options specific to replicated votes
message ReplicatedVote {}

