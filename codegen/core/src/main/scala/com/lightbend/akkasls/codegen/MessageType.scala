/*
 * Copyright 2021 Lightbend Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.lightbend.akkasls.codegen

import scala.jdk.CollectionConverters._

import com.google.protobuf.Descriptors

trait MessageType {
  def name: String
  def packageName: String
  def deriveName(derive: String => String): MessageType

  def fullName: String

  def typeImport = s"$packageName.$fullName"

  /**
   * The fully qualified type name as seen in generated Java/Scala code.
   */
  def fullyQualifiedName = s"$packageName.$name"

  /**
   * 'base' name of the file that will contain this MessageType relative to the package root,
   * i.e. 'com/example/MyService'
   */
  def fileBasename: String =
    packageName.replace('.', '/') + "/" + name
}

case class ClassMessageType(packageName: String, name: String) extends MessageType {

  override def deriveName(derive: String => String): MessageType =
    copy(name = derive(name))

  override def fullName: String = name
}

/**
 * A message type representing a simple Java/Scala type
 */
object ClassMessageType {
  def apply(fullQualifiedName: String): ClassMessageType = {
    val idx = fullQualifiedName.lastIndexOf('.')
    if (idx > 0)
      ClassMessageType(fullQualifiedName.take(idx), fullQualifiedName.drop(idx + 1))
    else
      throw new IllegalArgumentException(s"Expected fully-qualified name but got '$fullQualifiedName'")
  }
}

/**
 * A message type derived from proto message definitions.
 */
case class ProtoMessageType(
    protoName: String,
    name: String,
    parent: PackageNaming,
    descriptorObject: Option[ProtoMessageType])
    extends MessageType {

  /**
   * The fully qualified type name of the proto type. This should rarely be used during codegen, since language-specific
   * changes might have to be applied, and imports taken into account. In that case use the language-specific `typeName`
   * utility function instead.
   */
  lazy val fullyQualifiedProtoName = s"${parent.protoPackage}.$name"

  /**
   * The gRPC service interface generated by Akka gRPC (only useful if this ProtoMessageType actually refers to a
   * service)
   */
  lazy val fullyQualifiedGrpcServiceInterfaceName = s"$packageName.$name"

  lazy val fullName: String = {
    if (parent.javaMultipleFiles) name
    else s"${parent.javaOuterClassname}.$name"
  }

  lazy val descriptorImport: ProtoMessageType =
    descriptorObject.getOrElse(throw new IllegalArgumentException(s"$this is missing descriptor"))

  lazy val packageName: String = parent.javaPackage

  /**
   * Create a 'derived' name based on a name, such as 'FooProvider' based on 'Foo'.
   *
   * Notably also removes any outer class name from the parent, since 'derived' classes are always outside of the outer
   * class.
   */
  def deriveName(derive: String => String): ProtoMessageType =
    copy(name = derive(name), protoName = derive(protoName)).removeOuterClass

  def asJavaMultiFiles: ProtoMessageType =
    copy(parent = parent.asJavaMultiFiles)

  def removeOuterClass: ProtoMessageType =
    copy(parent = parent.copy(javaOuterClassnameOption = None, javaMultipleFiles = true))

}

object ProtoMessageType {

  /**
   * Creates a ProtoMessageType without a descriptor.
   */
  def noDescriptor(name: String, parent: PackageNaming): ProtoMessageType =
    ProtoMessageType(name, name, parent, None)

}

case class PackageNaming(
    protoFileName: String,
    name: String,
    protoPackage: String,
    javaPackageOption: Option[String] = None,
    javaOuterClassnameOption: Option[String] = None,
    javaMultipleFiles: Boolean = false) {
  lazy val javaPackage: String = javaPackageOption.getOrElse(protoPackage)
  def scalaPackage: String = javaPackage
  def javaOuterClassname: String = javaOuterClassnameOption.getOrElse(name)

  def asJavaMultiFiles: PackageNaming =
    copy(javaMultipleFiles = true)

  /**
   * This changes both the proto package and the javaPackage (if defined) This is useful when we derived a component
   * descriptor from a Service descriptor. In such a case, after we resolve the package where the component should live,
   * we need to modify it in order to have the file generated in the right package.
   */
  def changePackages(newPackage: String): PackageNaming = {
    val adaptedPackage = javaPackageOption.map { _ => newPackage }
    copy(javaPackageOption = adaptedPackage, protoPackage = newPackage)
  }

}

object PackageNaming {

  /**
   * Package for classes that aren't derived from a .proto
   */
  def noDescriptor(parent: String): PackageNaming =
    PackageNaming("", "", "", Some(parent), None, javaMultipleFiles = true)

  def from(descriptor: Descriptors.FileDescriptor): PackageNaming = {
    val name =
      descriptor.getName
        .split('/')
        .last
        .reverse
        .dropWhile(_ != '.')
        .tail
        .reverse
        .split('_')
        .map(s => s.headOption.fold("")(first => s"${first.toUpper.toString}${s.tail}"))
        .mkString

    val generalOptions = descriptor.getOptions.getAllFields.asScala.map { case (fieldDescriptor, field) =>
      (fieldDescriptor.getFullName, field)
    }

    val javaPackage =
      generalOptions.get("google.protobuf.FileOptions.java_package").map(_.toString())

    val javaOuterClassnameOption =
      generalOptions
        .get("google.protobuf.FileOptions.java_outer_classname")
        .map(_.toString())

    val javaOuterClassname =
      javaOuterClassnameOption.getOrElse {
        val existingNames =
          descriptor.getMessageTypes.asScala.map(_.getName) ++
          descriptor.getEnumTypes.asScala.map(_.getName) ++
          descriptor.getServices.asScala.map(_.getName)
        if (existingNames.contains(name)) name + "OuterClass" else name
      }

    val javaMultipleFiles =
      generalOptions.get("google.protobuf.FileOptions.java_multiple_files").contains(true)

    PackageNaming(
      descriptor.getName,
      name,
      descriptor.getPackage,
      javaPackage,
      Some(javaOuterClassname),
      javaMultipleFiles)
  }
}
