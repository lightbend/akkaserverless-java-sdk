# Kalix Spring SDK

(Note: since the Spring SDK is very recent, there is not yet proper documentation so this document aims to serve as a general introduction guide.)

The goal of the Spring SDK is to provide a code-first approach to developing Kalix applications so that a developer does not need to worry about learning protobuf upfront.

This SDK offers a way to develop applications which should be familiar to someone who has worked with Spring applications by making use of annotations to assemble Kalix and its components.

If you're new to Kalix and the different types of entities that exist in a Kalix app, consider reading [this section](https://docs.kalix.io/services/programming-model.html#_what_is_a_kalix_service) before continuing.  

## Features


### Value Entities

To define a Value Entity, one will need to do 4 simple steps:
1. create a class that extends `ValueEntity<S>`, where `S` is the state type this entity will store (what might usually be called a domain model class)
2. make sure to annotate such class with `@Entity` and pass in an `entityKey` and an `entityType`  
3. make use of Spring's RequestMapping annotation to define the routes to your entity
4. declare the methods that will handle the requests and update the state of the entity

```java
// ...
import kalix.springsdk.annotations.Entity;
import kalix.javasdk.valueentity.ValueEntity;

@Entity(entityKey = "id", entityType = "user") // <2>
@RequestMapping("/user/{id}") // <3>
public class UserEntity extends ValueEntity<User> { // <1>
    
    @PostMapping("/{email}/{name}") // <3>
    public Effect<String> createOrUpdate(@PathVariable String email, @PathVariable String name) {
        return effects()
                .updateState(new User(email, name)) // <4>
                .thenReply("Ok");
    }
}
```
From the above example, note:
- the entityKey `id` needs to match a path parameter and such value needs to be unique per entity
- the entityType `user` is common for all instances of this entity but should be unique across the different entity types
- the API to update the state is the same as the Java one (and is provided by `effects()`)


Below you can find a simple example of what the `User` model for the above entity could look like:
```java
public class User {
  public String email;
  public String name;
  
  @JsonCreator
  public User(@JsonProperty("email") String email, @JsonProperty("name") String name) {
    this.email = email;
    this.name = name;
  }
}
```

#### Sample
If you're looking for a working sample of a value entity, check [samples/spring-customer-registry-views-quickstart](../../samples/spring-customer-registry-views-quickstart). 


### Event-sourced Entity

To define an Event-Sourced Entity, be aware of the following aspects:
1. create a class that extends `EventSourcedEntity<S>`, where `S` is the state type this entity will store (what might usually be called a domain model class)
2. make sure to annotate such class with `@Entity` and pass in an `entityKey` and an `entityType`
3. make use of Spring's RequestMapping annotation to define the routes to your entity
4. declare the methods that will handle the requests/commands and emit the outgoing events
5. define the methods that will serve as handlers of the events generated by the commands by marking such methods with `@EventHandler`

```java
// ...
import kalix.javasdk.eventsourcedentity.EventSourcedEntity;
import kalix.springsdk.annotations.Entity;
import kalix.springsdk.annotations.EventHandler;

@Entity(entityKey = "id", entityType = "counter") // <2>
@RequestMapping("/counter/{id}") // <3>
public class CounterEntity extends EventSourcedEntity<Counter> { // <1>

  @Override
  public Counter emptyState() {
    return new Counter(0);
  }

  @PostMapping("/increase/{value}") // <3>
  public Effect<Integer> increase(@PathVariable Integer value) { // <4>
    return effects()
        .emitEvent(new ValueIncreased(value))
        .thenReply(c -> c.value);
  }

  @GetMapping // <3>
  public Effect<String> get() {
      return effects().reply(currentState().value.toString());
  }

  @EventHandler // <5>
  public Counter handleIncrease(ValueIncreased increased) {
      return currentState().onValueIncreased(increased);
  }

}
```
From the above example, note that:
- `entityKey` and `entityKey` have the same semantics as previously explained for Value Entities
- the `emptyState()` override is optional. If not using it, be careful to deal with a currentState() with a `null` value when receiving the first command
- there needs to be one event handler declared per each type of event the ES entity emits (e.g `handleIncrease` receives a param of type `ValueIncreased`, the same type emitted in `increase` command handler)

Below you can find a simple example of what the Counter model for the above entity could look like:
```java
public class Counter {
  public final Integer value;

  @JsonCreator
  public Counter(@JsonProperty("value") Integer value) {
    this.value = value;
  }

  public Counter increase(int byNum) {
    return new Counter(this.value + byNum);
  }

  public Counter onValueIncreased(ValueIncreased evt) {
    return new Counter(this.value + evt.value);
  }
}
```

#### Sample
If you're looking for a working sample of a event-sourced entity, check [samples/spring-customer-registry-views-quickstart](../../samples/spring-eventsourced-counter).

### Action

### Views

#### Views with transformation

### Subscribing to Value Entities

### Subscribing to Event-sourced Entities



## Upcoming features

The Spring SDK is more recent than their gRPC-first counterparts so some bits are not yet supported. Here's a list of the features that we are working on for the short-term:
- ACLs definition
- Timers


## Getting Started

The easiest way to get started is to use the `kalix-spring-boot-archetype` and let it generate a spring boot application for you.

```shell
mvn \
archetype:generate \
-DarchetypeGroupId=io.kalix \
-DarchetypeArtifactId=kalix-spring-boot-archetype \
-DarchetypeVersion=LATEST
```