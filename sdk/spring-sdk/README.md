# Kalix Spring SDK

(Note: since the Spring SDK is very recent, there is not yet proper documentation so this document aims to serve as a general introduction guide.)

The goal of the Spring SDK is to provide a code-first approach to developing Kalix applications so that a developer does not need to worry about learning protobuf upfront.

This SDK offers a way to develop applications which should be familiar to someone who has worked with Spring applications by making use of annotations to assemble Kalix and its components.

If you're new to Kalix and the different types of entities that exist in a Kalix app, consider reading [this section](https://docs.kalix.io/services/programming-model.html#_what_is_a_kalix_service) before continuing.  

## Features

As the Spring SDK is more recent than their gRPC-first counterparts, not all features are supported at this time. However, there's already a lot to play with as described next.

### Value Entities

To define a Value Entity, one will need to do 4 simple steps:
1. create a class that extends `ValueEntity<S>`, where `S` is the state type this entity will store (what might usually be called a domain model class)
2. make sure to annotate such class with `@Entity` and pass in an `entityKey` and an `entityType`  
3. make use of Spring's RequestMapping annotation to define the routes to your entity
4. declare the methods that will handle the requests and update the state of the entity

```java
// ...
import kalix.springsdk.annotations.Entity;
import kalix.javasdk.valueentity.ValueEntity;

@Entity(entityKey = "id", entityType = "user") // <2>
@RequestMapping("/user/{id}") // <3>
public class UserEntity extends ValueEntity<User> { // <1>
    
    @PostMapping("/{email}/{name}") // <3>
    public Effect<String> createOrUpdate(@PathVariable String email, @PathVariable String name) {
        return effects()
                .updateState(new User(email, name)) // <4>
                .thenReply("Ok");
    }
}
```
From the above example, note:
- the entityKey `id` needs to match a path parameter and such value needs to be unique per entity
- the entityType `user` is common for all instances of this entity but should be unique across the different entity types
- the API to update the state is the same as the Java one (and is provided by `effects()`)


Below you can find a simple example of what the `User` model for the above entity could look like:
```java
public class User {
  public String email;
  public String name;
  
  @JsonCreator
  public User(@JsonProperty("email") String email, @JsonProperty("name") String name) {
    this.email = email;
    this.name = name;
  }
}
```

#### Sample
If you're looking for a working sample of a value entity, check [samples/spring-customer-registry-views-quickstart](../../samples/spring-customer-registry-views-quickstart). 


### Event-sourced Entity

To define an Event-Sourced Entity, be aware of the following aspects:
1. create a class that extends `EventSourcedEntity<S>`, where `S` is the state type this entity will store (what might usually be called a domain model class)
2. make sure to annotate such class with `@Entity` and pass in an `entityKey` and an `entityType`
3. make use of Spring's RequestMapping annotation to define the routes to your entity
4. declare the methods that will handle the requests/commands and emit the outgoing events
5. define the methods that will serve as handlers of the events generated by the commands by marking such methods with `@EventHandler`

```java
// ...
import kalix.javasdk.eventsourcedentity.EventSourcedEntity;
import kalix.springsdk.annotations.Entity;
import kalix.springsdk.annotations.EventHandler;

@Entity(entityKey = "id", entityType = "counter") // <2>
@RequestMapping("/counter/{id}") // <3>
public class CounterEntity extends EventSourcedEntity<Counter> { // <1>

  @Override
  public Counter emptyState() {
    return new Counter(0);
  }

  @PostMapping("/increase/{value}") // <3>
  public Effect<Integer> increase(@PathVariable Integer value) { // <4>
    return effects()
        .emitEvent(new ValueIncreased(value))
        .thenReply(c -> c.value);
  }

  @GetMapping // <3>
  public Effect<String> get() {
      return effects().reply(currentState().value.toString());
  }

  @EventHandler // <5>
  public Counter handleIncrease(ValueIncreased increased) {
      return currentState().onValueIncreased(increased);
  }

}
```
From the above example, note that:
- `entityKey` and `entityKey` have the same semantics as previously explained for Value Entities
- the `emptyState()` override is optional. If not using it, be careful to deal with a currentState() with a `null` value when receiving the first command
- there needs to be one event handler declared per each type of event the ES entity emits (e.g `handleIncrease` receives a param of type `ValueIncreased`, the same type emitted in `increase` command handler)

Below you can find a simple example of what the Counter model for the above entity could look like:
```java
public class Counter {
  public final Integer value;

  @JsonCreator
  public Counter(@JsonProperty("value") Integer value) {
    this.value = value;
  }

  public Counter increase(int byNum) {
    return new Counter(this.value + byNum);
  }

  public Counter onValueIncreased(ValueIncreased evt) {
    return new Counter(this.value + evt.value);
  }
}
```

#### Sample
If you're looking for a working sample of an event-sourced entity, check [samples/spring-eventsourced-counter](../../samples/spring-eventsourced-counter).

### Actions

An Action can be defined by:
1. creating a class extending the `Action` interface
2. using Spring's RequestMapping annotations to define the routes to your entity and implement the command handlers 

```java
// ...
import kalix.javasdk.action.Action;

public class EchoAction extends Action { // <1>

  @GetMapping("/echo/{msg}") // <2>
  public Effect<Message> stringMessage(@PathVariable String msg) {
    return effects().reply(new Message(msg));
  }

}
```

#### Sample
If you're looking for a working sample of an action, check [samples/spring-fibonacci-action](../../samples/spring-fibonacci-action).

### Views

Generally, a view is defined in 3 steps:
1. creating a class that extends `View<S>`, where `S` is the event type this view will receive (what might usually be called a domain model class)
2. defining the source of events/updates by using one the `@Subscribe` annotations
3. providing a way to query the data using Spring's RequestMapping and Kalix `@Query` annotations 

There are the slight differences depending on the type of entity the view is subscribing to, which we will describe  next. 

#### Subscribing to a Value Entity 

To subscribe to a Value Entity, use `@Subscribe.ValueEntity` annotation to provide the respective Entity type as follows:

```java
// ...
import kalix.javasdk.view.View;
import kalix.springsdk.annotations.Query;
import kalix.springsdk.annotations.Subscribe;
import kalix.springsdk.annotations.Table;

@Table("users_by_email")
@Subscribe.ValueEntity(UserEntity.class)
public class UsersByEmail extends View<User> {

  @GetMapping("/users/by_email/{email}")
  @Query("SELECT * FROM users_by_email WHERE email = :email")
  public User getUsers(String email) {
    return null;
  }
}
```

From the above example, note that:
- we are subscribing to updates of `UserEntity` (from the example provided in the [Value Entities section](#value-entities))
- the type of updates is `User` as defined in `extends View<User>` since that is the state type of the `UserEntity`
- the query method `getUsers` needs to have a dummy implementation for now (which is not used)

#### Sample
If you're looking for a working sample using a view, check [samples/spring-customer-registry-views-quickstart](../../samples/spring-customer-registry-views-quickstart).


#### Views with transformation

### Subscribing to Value Entities

### Subscribing to Event-sourced Entities



## Testing

The only type of testing available at the moment are Integration tests. You can do such a test by:

[TODO: complete here]

## Upcoming features

Here's a list of the features that we are working on for the short-term:
- ACLs definition
- Timers support
- Unit testing

And much more to come later. :)

## Getting Started

The easiest way to get started is to use the `kalix-spring-boot-archetype` and let it generate a spring boot application for you. Try:

```shell
mvn \
archetype:generate \
-DarchetypeGroupId=io.kalix \
-DarchetypeArtifactId=kalix-spring-boot-archetype \
-DarchetypeVersion=LATEST
```