/* This code was generated by Kalix tooling.
 * As long as this file exists it will not be re-generated.
 * You are free to make changes to this file.
 */

package com.example.fibonacci;

import akka.NotUsed;
import akka.japi.Pair;
import akka.stream.javadsl.Source;
import kalix.javasdk.action.ActionCreationContext;

import java.util.Optional;
import java.util.concurrent.CompletionStage;
import java.util.function.Predicate;

public class FibonacciAction extends AbstractFibonacciAction { // <1>

  public FibonacciAction(ActionCreationContext creationContext) {}


  // tag::implemented-action[]
  private boolean isFibonacci(long num) {  // <1>
    Predicate<Long> isPerfectSquare = (n) -> {
      long square = (long) Math.sqrt(n);
      return square*square == n;
    };
    return isPerfectSquare.test(5*num*num + 4) || isPerfectSquare.test(5*num*num - 4);
  }
  private long nextFib(long num) {
    double result = num * (1 + Math.sqrt(5)) / 2.0;
    return Math.round(result);
  }

  @Override
  public Effect<FibonacciApi.Number> nextNumber(FibonacciApi.Number number) {
    long num = number.getValue();
    if (isFibonacci(num)) { //<2>
      long nextFib = nextFib(num);
      FibonacciApi.Number response =
          FibonacciApi.Number
              .newBuilder()
              .setValue(nextFib)
              .build();
      return effects().reply(response);
    } else {
      return effects() //<3>
               .error("Input number is not a Fibonacci number, received '" + num + "'");
    }
  }
  // end::implemented-action[]


  @Override
  public Source<Effect<FibonacciApi.Number>, NotUsed> nextNumbers(FibonacciApi.Number number) {
    long num = number.getValue();
    if (!isFibonacci(num)) {
      return Source.single(effects().error("Input number is not a Fibonacci number, received '" + num + "'"));
    } else {
      return Source.unfold(num, previous -> {
        long next = nextFib(previous);
        Effect<FibonacciApi.Number> nextEffect =
            effects().reply(FibonacciApi.Number.newBuilder().setValue(next).build());
        return Optional.of(Pair.create(next, nextEffect));
      });
    }
  }

  @Override
  public Effect<FibonacciApi.Number> nextNumberOfSum(Source<FibonacciApi.Number, NotUsed> numberSrc) {
    // contrived but just to stay in fibonacci land with a streamed in call
    CompletionStage<Effect<FibonacciApi.Number>> effect = numberSrc.runFold(0L, (acc, number) -> acc + number.getValue(), actionContext().materializer())
        .thenApply(sum -> {
          if (isFibonacci(sum)) {
            return effects().reply(FibonacciApi.Number.newBuilder().setValue(nextFib(sum)).build());
          } else {
            return effects().error("Input sum is not a Fibonacci number, received '" + sum + "'");
          }
        });

    return effects().asyncEffect(effect);
  }

  @Override
  public Source<Effect<FibonacciApi.Number>, NotUsed> nextNumberOfEach(Source<FibonacciApi.Number, NotUsed> numberSrc) {
    return numberSrc.map(number -> {
      long num = number.getValue();
      if (!isFibonacci(num)) {
        return effects()
            .error("Input number is not a Fibonacci number, received '" + num + "'");
      } else {
        return effects().reply(FibonacciApi.Number.newBuilder().setValue(nextFib(num)).build());
      }
    });
  }
}